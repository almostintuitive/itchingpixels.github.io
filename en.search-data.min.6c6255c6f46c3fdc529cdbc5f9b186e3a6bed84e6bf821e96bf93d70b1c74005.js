'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/technical/','title':"Technical",'content':"Technical "});index.add({'id':1,'href':'/docs/quantitative-finance/','title':"Quantitative Finance",'content':"Technical "});index.add({'id':2,'href':'/docs/archived-posts/','title':"Archived posts",'content':"Archived posts Posts from my old blog, they\u0026rsquo;ll be here until I move them somewhere else (or delete them).\n"});index.add({'id':3,'href':'/docs/quantitative-finance/alpha-vs-beta/','title':"Alpha vs beta",'content':"Alpha vs beta Let\u0026rsquo;s start with the definitions:\nAlpha Excess returns you gain over the market.\n Only available to you. Requires you to have an edge (information that\u0026rsquo;s not baked into the price already). Zero-sum game. If you gain, somebody loses. Short-lived. As soon as the market finds about your edge, it\u0026rsquo;ll arbitrage it away.  As a retail (non-institunioal) investor, your alpha (edge) sources are limited. Anything well-known is probably arbitraged away already (if it can be), by the time the info reaches you.\nRelated note about \u0026ldquo;the unnecessary urge to search for alpha\u0026rdquo;\nBeta Returns attributed to taking a \u0026ldquo;risk premium\u0026rdquo;.\n Available for anyone. Doesn\u0026rsquo;t require any edge. Non-zero sum game. You, and everyone else gains. Long-lived. As long as the vehicle / market works, it\u0026rsquo;ll be available for everyone.  Beta can manifest itself in various ways:\n Seeking yield (eg. buying bonds) Value (eg. buying relatively cheap companies) Growth (eg. buying stocks that are on a good trajectory) Selling insurance (reducing someone else\u0026rsquo;s exposure to volatility)  "});index.add({'id':4,'href':'/docs/','title':"Docs",'content':""});index.add({'id':5,'href':'/docs/quantitative-finance/the-reasons-against-discretionary-investing/','title':"The reasons against discretionary (non-systematic) investing (like stock picking, etc)",'content':"The reasons against discretionary (non-systematic) investing (like stock picking, etc) 1. As a retail investor (with fees against you, and being an outsider), you have no obvious edge over the market.\n2. If something seems under- or overpriced to you, you probably don’t have all the info, and the market is most probably right.\n3. Even if your views are correct, there’s a huge amount of uncertainty in the future, that’s not connected to you being right or wrong, which can result in a much larger impact on your bet / investment - aka your edge may only play a very small role in your positive or negative returns.\n4. Even in hindsight, you’ll not be able to verify if the price went up or down because of your insight, or other factors. You can build up your ego in an up-market easily by seeing your assumptions frequently being validated, without benchmarking for total market returns or objectively evaluating the situation.\n5. Mixing your personality (I like Crocs sandals, and their brand) with your investment decisions (therefore I’ll buy Crocs stock) is dangerous, as you can get into a situation where your ego is conflicting with your financial well-being. We’re all humans though - good luck detaching your personality from the rest of your decisions!\n6. Everything that’s in the mainstream financial press is not worth your attention.\n"});index.add({'id':6,'href':'/docs/technical/sync-endpoints/','title':"Sync APIs - git patch inspired non-blocking client-server communication pattern",'content':"Sync APIs - git patch inspired non-blocking client-server communication pattern Three years ago, we were in a desperate need for a mental model: how to structure the highly asynchronous, non-blocking communication we have between our backend and mobile clients - where Read/Update are the only meaningful operations.\nThe solution we ended up with was something different than the currently popular CRUD / REST APIs (but closer to GraphQL’s) - and rather close to the concept of git’s patches / diffs.\nLinux kernel developers were sending patches to mailing lists, and releases were assembled by applying these patches. While this sounds like a horrendous model for release management today (I guess it works though!) - but as a mental model for reliably communicating changes, it may be a good alternative to the currently popular conventions in certain cases.\nCRUD (the basis of REST apis) stands for Create Read Update Delete - which seemed a little bit of an overkill at that time for our use case:\n We had tons of small records, instead of a couple of big ones. Individual, non-batched updates wouldn’t have been efficient or easy to manage. There was no need for “Delete”. “Create” was really easy to couple with “Update”. So easy that differentiating between them would have only caused extra headaches.  So, from CRUD, we needed “RU”.\nBut\u0026hellip; the biggest problem wasn’t the unnecessary operations - but managing what happens when the user goes offline for a month, and then comes back online. Our worry was that, then the client could suddenly start sending out-of-date, cached requests to the backend. The worst case would have been for us to lose that data, or the up-to-date properties being overwritten with previous ones.\nThe use case of Sync APIs Two different communication patterns I see in contemporary software:\n software relying on frequent, blocking, real-time interaction (a social network, for example) software relying on infrequent, non-blocking interaction with the server, which mostly stores data that the client needs to time-to-time (potentially, on different devices). There are two different ways of how we could communicate change: in a batch (as a transaction) or individual changes, one-by-one. (a presentation tool, a game, a brain training app or a mostly single-player experience)  Example: You have 3 post-its.\ninterface PostIt { title: string status: “Available” | “Deleted” content: string }  The actions you’ve done:\n You changed the 1st, named “birthdays” - PUT request to note/birthdays Then, you deleted the 1st, named “birthdays” - DELETE request to note/birthdays Then, you changed the 2nd, named “friends”. - PUT request to note/\u0026lt;2nd name\u0026gt;  You could batch these, and only communicate the diff, if you added a property that would store the last action’s date/time.\ninterface PostIt { title: string status: “Available” | “Deleted” content: string lastModified: number }  A timestamp (lastModified) here would open up the possibility to compare and merge conflicting data effectively, by comparing what happened last.\nmergePostIts = (lhs, rhs): PostIt =\u0026gt;  Okay, right now it seems like we can only merge whole PostIts - as we only have one lastModified available. This means both status and content will be replaced with the value that was modified later. But… what if on one client, we changed the status, and on another, we changed the content? Well, you’d lose that information. But there’s a way to prevent that from happening: have a timestamp on a property level, rather than on the larger context.\nInterface PostIt { status: { Value: “Available” | “Deleted” lastModified: number } content: { Value: “Available” | “Deleted” lastModified: number } }  Advantages of Sync APIs If you don’t need a separate “Create” operation, and your client-server communication can be made non-blocking for the user, the advantages of Sync APIs over CRUD/REST or GraphQL are:\n Offline support is easy. If the client can’t connect, it can still fall back to the local data it has. As every property has a timestamp, means it will be diffable on the backend later. Business logic is concentrated on the backend. The frontend blindly accepts (with some basic safety checks) what the backend returns. Conflict resolution is easy (or, even free) if there are multiple clients editing the same data. It’s easier to debug, as the business logic sits in the backend (the thing you’d debug) You can reduce the number of requests  We use Sync APIs at Drops. Ours is probably the perfect usecase - we’re mobile (lots of offline usage), and there’s no real-time interaction, but it is possible that you play on multiple devices, and modify the same data.\nOur frontend is written with React-native, and we’re using redux for state management. To make it easy to store lastModified timestamps, we wrote a higher level reducer that automatically adds a timestamp for each change (when it was initiated by the user).\nCaveats of Sync APIs   If a blocking “Create” operation is necessary (for example, because it’d generate a unique id), you can not use Sync APIs exclusively.\n  Have you noticed that git will create inconsistencies when you set your system’s time to arbitrary values? Probably not. But believe me, it does! Anyway, keeping the client’s clock “real” is a challenge. You may need to delay communication with the backend until you find that the time stamps are correct and are not in the future.\n  It may be useful to implement a mechanism on the backend side as well to filter out changes that happened “in the future”. Otherwise these users may not be able to override something they set while “in the future”.\n  "});index.add({'id':7,'href':'/docs/archived-posts/2016-01-30-functional-reactive-intuition-swift/','title':"2016 - Functional Reactive Intuition - Swift edition",'content':"Functional Reactive Intuition - Swift edition So, you’ve heard about reactive programming. Then you got discouraged, almost immediately.\nLike: is this guy really talking about switching on the observable of observables? I have no idea what\u0026rsquo;s going on.\nThat’s all fine, we agree on one thing: people usually try to explain functional programming in a way that only makes sense to people who already know functional programming.\nLet me show you something, maybe it can help with your appetite.\nHave you heard of pipes? streams? signals? observables? eventemitters? Let’s imagine they’re all the same: channels that emit events, over time.\nAnd just in this moment, your boss interrupts you. She asks you to implement a new feature in the app. She gives you this brief:\nWhen the user starts simultaneously panning and rotating an object, start a countdown from 3. Stop the timer either when the countdown ends or when the user stops the gestures. This is gonna be a mission critical part of the app. There’s no way you can make a mistake here.\nSo, as an imperative programmer, you start thinking about what do you need to keep track of in order to implement this: Let’s see:\n\u0026ldquo;user starts simultaneously panning and rotating an object\u0026rdquo; - okay, I need to store this in a variable. I mean, otherwise how else can I check if both of them happening at the same time?\n“Stop the timer either when the countdown ends” - means I’ll need to keep track of the timer. And also, the number of seconds left.\nEtc, etc.\nSo, you get the idea: we’re building a kind-of data structure describing what’s exactly happening at the screen, in this specific moment, so we can compare the old state with the new state - this is how we\u0026rsquo;re building our control-flow. With ifs.\nvar panPresent = false var pinchPresent = false var gestureTimer: NSTimer? var secondsLeft = 3 func handlePan(panGesture: UIPanGestureRecognizer) { if panGesture.state == .Began \u0026amp;\u0026amp; self.panPresent == false { self.panPresent = true self.checkIfBothGesturesPresent() } else if panGesture.state == .Ended { self.panPresent = false self.stopTimerIfNeeded() } } func handlePinch(pinchGesture: UIPinchGestureRecognizer) { if pinchGesture.state == .Began \u0026amp;\u0026amp; self.pinchPresent == false { self.pinchPresent = true self.checkIfBothGesturesPresent() } else if pinchGesture.state == .Ended { self.pinchPresent = false self.stopTimerIfNeeded() } } func checkIfBothGesturesPresent() { if self.pinchPresent == true \u0026amp;\u0026amp; self.panPresent == true \u0026amp;\u0026amp; self.gestureTimer == nil { self.secondsLeft = 3 self.gestureTimer = NSTimer.scheduledTimerWithTimeInterval(1, target: self, selector: “tick:”... print(\u0026quot;started\u0026quot;) } } func stopTimerIfNeeded() { if let gestureTimer = gestureTimer { gestureTimer.invalidate() self.gestureTimer = nil print(\u0026quot;completed\u0026quot;) } } func tick(timer: NSTimer) { if self.secondsLeft \u0026lt;= 0 { self.stopTimerIfNeeded() return } self.secondsLeft-- print(\u0026quot;tick\u0026quot;) }  So, we turned our original sentence into this:\n- When the user touches the screen - Check if a user is panning an object, store that information - Check if both gestures are running simultaneously - start a timer, from 3, counting down. - Check if the user is rotating an object, store that information - Check if both gestures are running simultaneously - start a timer, from 3, counting down. - Check if the user stopped panning - Stop the timer if needed - Check if the user stopped rotating - Stop the timer if needed - When the timer ticks, decrease the number of seconds left - If the number of seconds left is zero, stop the timer  Ohh my god, it involves having 4 temporarily variables expressing the state of the UI!\nAlso, it is nothing like the original English sentence. The logic is buried between if statements, where we set random booleans. We write functions to eliminate duplicated code. And the we jump around like an inconsistent bugs bunny - there are 5 of them, all calling each other.\nHow can we improve upon this?\nSo, the question that reactive programming can help you with is:\nHow can you replace all those \u0026ldquo;if\u0026rdquo; instances with \u0026ldquo;when\u0026rdquo;? Let\u0026rsquo;s have a look!\nlet pan = UIPanGestureRecognizer() let pinch = UIPinchGestureRecognizer() // Here, we want to create a signal that emits an event when the // gesture has started. // We can call .rx_event on UIPangestureRecognizer, and // transform it's output into a signal, which then // We can use filter to discard all other events! let panStarted = pan.rx_event.filter { gesture in gesture.state == .Began } // We do the same here, but this time we're only interested // when the gestureRecognizer is in the .Ended state. let panEnded = pan.rx_event.filter { gesture in gesture.state == .Ended } let pinchStarted = pinch.rx_event.filter { gesture in gesture.state == .Began } let pinchEnded = pinch.rx_event.filter { gesture in gesture.state == .Ended } // Okay, let's think. Our aim is to only trigger the timer when both // gestures began. We originally had to keep track of these states ourselves, // but now that we transformed them into signals, we can also merge them, same // way as you'd merge two arrays into one! // Well, not exactly, we need a special combination, where the new signal will only // start when both of its sub-signals have emitted an event: that's combineLatest(). let bothGesturesStarted = Observable.combineLatest(panStarted, pinchStarted) { (_, _) -\u0026gt; Bool in return true } // For gestures ended, we need merge(), since we don't need to wait until both of // them has started, we can immediately forward events from both channels into // the combined one. let bothGesturesEnded = Observable.of(panEnded, pinchEnded).merge() // Now that we have our starting point, what should we do? // Signals are special beasts: you can subscribe to them. Same way as // you'd subscribe to a notification through NSNotificationCenter. // subscribeNext will take a closure (block), and every time the signal // fires, it'll run the signal's emitted value through the block! bothGesturesStarted.subscribeNext { _ in // So, when bothGesturesStarted started, do this: print(\u0026quot;started\u0026quot;) // Now we need to create a timer. Rx is a quite comprehensive library, // it has some really handy structures and extensions - one of them is // exactly a timer. // What do we want? If we don't want to keep track of any more state, // we can just create a signal that emits a number (Int), and increase it // on every 'tick'. let timer = Observable\u0026lt;Int\u0026gt;.timer(1, period: 1, scheduler: MainScheduler.instance) // But wait, we don't want this timer to go on indefinitely! // Hmm, actually this is quite easy. Rx will also provide you operations // where you can limit the lifetime of a signal. // Same way as you'd take only the first 3 items in the array, you can // use take(x) to only take the first x events (values) from a signal. let timerThatTicksThree = timer.take(3) // And finally, we can also combine signals in other ways: this time, // we need to stop the timer signal when another signal is fired. // Here, we just use takeUntil! It's like the \u0026quot;while\u0026quot; loop of signals. let timerThatTicksThreeAndStops = timerThatTicksThree.takeUntil(bothGesturesEnded) timerThatTicksThreeAndStops.subscribe(onNext: { count in // when a tick happens, do this: print(\u0026quot;tick: \\(count)\u0026quot;) }, onError: nil, onCompleted: { // when the timer completes, do this: print(\u0026quot;completed\u0026quot;) }, onDisposed: nil) }  And now, voila, all four of the temporary variables are gone! Also, did you notice, that the code looks like this:\ndefine condition “simultaneously panning and rotating” define condition “start a countdown from 3” define condition “when the user stops the gestures” define what a timer is now do this: “When the user starts simultaneously panning and rotating an object, start a countdown from 3. Stop the timer either when the countdown ends or when the user stops the gestures.”  You can also compress the syntax quite a bit, if you want to see how, here\u0026rsquo;s the link to the file!\nHave a look at the example project here and feel free to play around.\nDoes this makes sense? Let me know what you think!\n"});index.add({'id':8,'href':'/docs/archived-posts/2016-01-09-big-s-notation/','title':"2016 - Big S(tate) notation",'content':"Big S(tate) notation This is an early and somewhat funny/incomprehendible post I wrote a long time ago about stateless / stateful components (not in a React, sense, but more in an OOP, object-sense).\nThere’s something that bothers me a little bit:\nWe have this useful thinking tool, Big 0 notation, to measure the computation complexity of an algorithm / function.\nAnd it\u0026rsquo;s great! We can anticipate the amount of time that a certain operation could take, and the necessary memory we need prepare for it, and it helps us architect our software, and forsee future problems without actually writing a line of code.\nBut, do we have a good thinking tool for the understanding (human) complexity of a component?\nI’ll struggle a little bit here, since I don’t have a clear definition of “understanding complexity”.\nMaybe it’s easier to just describe what a simple component is in my mind:\n has very little or no state mutates its state very rarely (or never) it’s easy to reproduce a situation where the component is in a certain kind of state.  I’d consider a string conversion component very simple, since all its functions will be pure: they’ll get an input string and they’ll produce an output string.\nIn contrast, a complex component:\n has lots of states mutates its state very frequently it’s hard to reproduce a situation where the component is in a certain kind of state.  I’d consider a database component to be very complex, since none of its public functions will be pure: it’ll have to insert, modify and delete records, write them to the disk, cache them, etc.\nIt could be very useful to have a thinking tool for this kind of complexity: let’s call it the big S(tate) notation.\nBut… could for example, a linter or a complier classify a component as “complex” or “simple”? Would it be possible to find that out, just by parsing the code and identifying some keywords?\nThere are two ideas to play with:\nHow many variables are defined in global scope of the component (aka. properties)? This will give you a good indication of how many different state it can have.\nWhat’s the ratio of pure vs. impure functions (methods) the component has?\n Sorry if I jumped too far too quickly - let’s define what pure and impure functions are. This is not something I made up, promise. They even have wikipedia articles!\nLet’s say: A pure function is where you don’t modify or read anything outside of the scope of the function. You get the parameters, you transform them, and you return a value. It’s completely predictable - call it twice with the same input, and it’s guaranteed that it’ll produce the same result.\nAn impure function is where you take some parameters, but you also access some other properties of the component, change them, and then you return a value. It can be unpredictable - call it twice with the same input, and you can be never sure if you get the same result - since it’s using (and possibly) modifying state, outside of its parameters.\nA pure function is like asking your computer to turn down the music it’s playing. It’ll do it as soon as you press the button.\nAn impure function is like asking a neighbour to turn down the music while it’s having a house party. He/she may say “go to hell” and turn up the volume in response, depending on how drunk he/she is, and various other factors.\n The million dollar question is:\nHow can you reduce the understanding complexity of a component that’s main function is to mutate its state?\nSo that you can’t remove any of its defined variables.\nIs that possible? Now, if we have a look at the Big S(tate) notation definition above, we can slightly rephrase this question to:\nCan you increase the ratio of pure vs. impure functions in your component?\nWhat do you think? Does this make sense?\nI’ll continue later, but if you’re curious, have a look at redux and the explanation of how it works by its author.\nShout on twitter if you find this horrendous / incorrenct or something you can relate to, I\u0026rsquo;d love to hear about it.\n"});index.add({'id':9,'href':'/docs/archived-posts/2016-01-08-making-mistakes/','title':"2016 - Making mistakes",'content':"Making mistakes For a long time, my profile said “I make complex simple”.\nWell, first of all, it would have been more accurate to say: \u0026ldquo;I try to make complex simple but I fail most of the time\u0026rdquo;.\nAlso, I don\u0026rsquo;t like the super-confident picture \u0026ldquo;I make complex simple.\u0026rdquo; is carrying.\nSo now I can rephrase my motto to: “I make lots of mistakes while trying to make complex simple”. But then, reducing complexity, keeping things as simple as possible is kind of what engineers do anyway, at least in my mind, so I can leave that out.\nIn short: “I make mistakes.\u0026rdquo;\nSo, from now on, my profile will just say that.\nIt’s extra convenient since I don’t ever have to think about whether it is still true or not ;).\nAlso, I hope this will help be more freely discuss my thoughts and ideas, that are obviously wrong anyway.\n"});index.add({'id':10,'href':'/docs/archived-posts/2015-08-09-post-text-messaging/','title':"2015 - Post-text messaging?",'content':"Post-text messaging? Have you ever been thinking about this little symbol?\nI sometimes do. It gives me that anticipation, that sense of presence, which always makes conversations a lot more enjoyable.\nI have a question though.\nWhy do we have this representation of a conversation as the standard?\nThis feels like something we inherited from here:\nIt does seem really useful to see the chronological order of the sentences, I have to admit.\nBut, what about… when you’re both present?\nI feel like, that’s a special case, which can be a lot more… emotional? And also, where non-verbal self-expression can be a priority. I mean, in real life, I don’t have to wait till you finish a sentence to react - I can wave my hands, I can pull a face, I can start shouting.\nIf I want to represent a real-life, real-time conversation, it would look somewhat similar to this:\nWhat if we dropped the strict chronological order in your favourite messaging app?\nThen you could react to a message in an instant\u0026hellip;\nI have a very simple, buggy prototype right now that will enable you to drag messages around: Github\nCan I throw it away?\nCan I put it upside down?\nCan I tilt it slightly to make space for a new topic?\nCan I make the important ones bigger?\n.. what else could I do?\nIf anything comes to your mind, ping on twitter!\nThis whole concept came from the long conversations with @marblekittykat, @bonsaielectric, @dmvrg\n"});index.add({'id':11,'href':'/docs/archived-posts/2014-09-07-anatomy-of-a-touch-interaction-swipe-to-peep/','title':"2014 - Anatomy of a touch interaction: Swipe-to-peep",'content':"Anatomy of a touch interaction: Swipe-to-peep You open up your messaging app. Question: Why can’t you just \u0026ldquo;peep\u0026rdquo; into the thread by swiping on a conversation cell like this?\nToday’s state of interaction design seems a bit swipe-obsessive, right? But really, why do people love to cuddle their phone? Does swiping really make touch interactions seem more effortless?\nMailbox, the iOS app I’m using stopped working for a few days for me, so I went back to the Gmail app, and I was like, how can people use this? It felt like flicking through my emails took me twice as long. Which was clearly not true. Otherwise I would have just abandoned emails. Mailbox helps with dealing with obvious spam, or emails that you expect to receive, but not the ones that require any examination - then you’re still tapping on the email, it slides to another view, then you see that ohh it’s just your aunt asking you about whether you can make it next month to a large family gathering, which you promptly delete so you can pretend that you’ve never received it.\nOkay now I’m curious, let’s have a look at some chat apps. You’ve got some arbitrary actions if you swipe on a conversation:\nSeems kind of useless, there are other ways to delete a thread if you want to.\nIs this time to do a prototype? Hell yeah!\nFor the ones who’re interested in the technical details, we’re creating a UITableViewCell that if you start dragging (just add a UIPanGestureRecognizer), communicates with the main ViewController through a delegate. We\u0026rsquo;ll trigger the final transition (full-screen content view) if the drag movement ended on the left side of the screen.\nif (gestureRecognizer.state == UIGestureRecognizerStateBegan) { [self.delegate swipeableCellDidStartSwiping:self]; } else if (gestureRecognizer.state == UIGestureRecognizerStateChanged) { [self.delegate swipeableCell:self didSwipeWithHorizontalPosition:touchLocation.x progress:progress]; } else if (gestureRecognizer.state == UIGestureRecognizerStateEnded) { if (progress \u0026gt;= 0.7) { [self.delegate swipeableCellCompletedSwiping:self]; } else { [self.delegate swipeableCellCancelledSwiping:self]; } }  Now let’s just create a a second view and move it (its left side) along the path you leave with your finger.\n- (void)adjustViewBasedOnSwipeProgress:(float)progress { self.postWebView.center = CGPointMake(self.view.center.x+(self.view.bounds.size.width*progress), self.view.center.y); }  Easy.\nThis is not exactly how the Mailbox swipe interaction works, but if you just grab the tile from the current position, you’ll never see enough of the content to make \u0026ldquo;peeping\u0026rdquo; work.\nOkay, I found a problem though: If you just swipe on a TableView Cell, it just jumps back, we don\u0026rsquo;t trigger the new screen.\nSolution: Let\u0026rsquo;s check the horizontal velocity (the speed) of the swipe and base the decision also on that:\nelse if (gestureRecognizer.state == UIGestureRecognizerStateEnded) { if (progress \u0026gt;= 0.7 || touchVelocity.x \u0026lt; -300) { [self.delegate swipeableCellCompletedSwiping:self]; } else { [self.delegate swipeableCellCancelledSwiping:self]; } }  Okay, let\u0026rsquo;s come back to this a bit later. What happens with the visual transition? It feels a clunky. What if we move the original screen to the left at the same time?\n- (void)adjustViewBasedOnSwipeProgress:(float)progress { self.tableView.center = CGPointMake(self.view.center.x-(self.view.bounds.size.width*(1-progress)), self.view.center.y); self.postWebView.center = CGPointMake(self.view.center.x+(self.view.bounds.size.width*progress), self.view.center.y); }  Cool, makes a bit more sense. What if we do a bit of a “parallax” movement with the original screen? Also, fade out the original?\n- (void)adjustViewBasedOnSwipeProgress:(float)progress { self.tableView.alpha = progress; self.tableView.center = CGPointMake(self.view.center.x*progress, self.view.center.y); self.postWebView.center = CGPointMake(self.view.center.x+(self.view.bounds.size.width*progress), self.view.center.y); }  Okay, fine. But, in general, scrolling on the conversation list is crap. It\u0026rsquo;s a bit hard to illustrate with only a few;), but the \u0026ldquo;content screen\u0026rdquo; will suddenly start jumping in when you slightly move to the right:\nLet’s disable the “swipability” on the cell when the vertical acceleration (scrolling on the table) is larger than the horizontal acceleration (swiping to reveal the content)\n- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)gestureRecognizer { if ([gestureRecognizer class] == [UIPanGestureRecognizer class]) { CGPoint velocity = [gestureRecognizer velocityInView:nil]; if (fabsf(velocity.x) \u0026gt; fabsf(velocity.y) ) { return YES; } return NO; } return YES; }  But now, we have to disable scrolling on the main screen’s tableview, otherwise you’ll get this weird effect:\n- (void)swipeableCell:(SwipeToPeepCell *)cell didSwipeWithHorizontalPosition:(CGFloat)horizontalPosition progress:(float)progress { self.tableView.scrollEnabled = NO; [self adjustViewBasedOnSwipeProgress:(1-progress)]; }  Okay, but you can still scroll to the other direction (right), and have a view popping where your finger is. Really confusing. Let’s not do that.\nif (velocity.x \u0026gt; 0) { return NO; }  Now that we’re here, we could try out pop by Facebook (an awesome animation framework). It’s awesome, and with MCAnimate+POP, the syntax is as concise as it can get. With one extra keypath addition, you can do fancy stuff! Just type in \u0026ldquo;.spring\u0026rdquo; before whatever you want to animate.\n- (void)adjustViewBasedOnSwipeProgress:(float)progress { self.tableView.spring.alpha = progress; self.tableView.spring.center = CGPointMake(self.view.center.x*progress, self.view.center.y); self.postWebView.spring.center = CGPointMake(self.view.center.x+(self.view.bounds.size.width*progress), self.view.center.y); }  Smooth!\nThe problem now is that you have no feedback on the cell what you’ve selected\u0026hellip; Let’s animate the background color of cell you\u0026rsquo;re swiping on in a hacky way!\n- (void)changeBackgroundColorBasedOnProgress:(float)progress { self.interactiveBackground.alpha = progress; } - (void)didMoveToSuperview { self.interactiveBackground = [[UIView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, self.bounds.size.height)]; self.interactiveBackground.backgroundColor = [UIColor flatGrayColor]; self.interactiveBackground.alpha = 0; [self insertSubview:self.interactiveBackground atIndex:0]; }  This probably makes more sense without the other animation, that fades out the original view completely. But it\u0026rsquo;s something!\nReady for primetime?\nProbably not.\nIf you\u0026rsquo;re intrigued, download the prototype from github and try it out yourself!\nDon’t ever use any of the hacky solutions I’ve used here in your production code, or Jonathan Ive will come around and redesign your face into an aluminium ball with a blinking light. You need the UIViewControllerTransition API and all that fancy stuff. It’s fine, you can do it. I know it’s confusing, but good people wrote wrappers around it. Minus one horrible API you need to learn!\nThere\u0026rsquo;s a branch in the repository that has a working HackerNews client with the same interaction - the only problem is that downloading \u0026amp; rendering a web page takes around 5 seconds on your phone, so \u0026ldquo;peeping\u0026rdquo; is not that instant, which makes it kind of useless. Tip from Peter: render it on the server side!\nWhat else would you use this for? I have nothing in the pipeline, so please, steal if if you want. And ping me on twitter!\n(Yeah I have no intention writing another messaging app. Please publicly execute me if I do.)\n"});index.add({'id':12,'href':'/docs/archived-posts/2014-03-24-todays-mobile-context-insensitivity/','title':"2014 - Today’s mobile context-insensitivity",'content':"Today’s mobile context-insensitivity  The supercomputers we’re carrying around don’t know what we are doing and what we are up to — and that’s a problem.\n I have an iPhone. The technology inside is so advanced that I can’t even imagine — and there’s no chance I can actually understand it. Its operating system has a built in physics engine, a database management system, OpenGL, and many awesome features and it would take me half an hour to list them all. But… it can’t turn on the wi-fi automatically when I’m at home. (There are a few reasons why you don’t want to have your wi-fi always on.)\nActually, this is a bad example. It could do so much more. It could find me a flower shop nearby before my date tonight, it could\nWell, at least on Android, I have apps that could turn on my wi-fi when I get home.\nHow do they work? You install “WiFi Auto-switch”, which subscribes to location monitoring. Then you realize that you also want to turn on your smart thermostat when you get home. You install “Smart Thermostat Control”.\nOhh, you forget another one: turn off the lights. So you download “Smart Light Control”…\nBut, location monitoring in itself is meaningless — they also have to know where “home” is. And yes, they\u0026rsquo;ll ask you three times, because there\u0026rsquo;s no central place where you can store this information.\nBut.. this why doesn’t your phone have an event API on the OS level that triggers specific apps when you leave the office, when you get on a train, before you leave for a holiday and when you’re about to have a date with your girlfriend? It could have access to your calendar, your location, your emails. So before your date, Yelp could check whether there’s a flower shop nearby and send you a notification if it found any, Gmail can automatically send an email to your Mum if you arrived safely to your destination, or whatever.\nThere are many apps that are doing these individually anyway, but there’s a gap — they can’t really interact with each other and therefore become really useful. On Android, this could happen tomorrow — as Google Now already knows when you are near to a bus station, have a flight to catch, etc. You just need to access that information as an app and build services upon it. And Apple bought the personal assitant/smart calendar startup Cue in 2013\u0026hellip;\nWe also have IFTTT, which could easily fill the gap — if the design of iOS would let it. Unfortunately, the way of it deals with the problem feels more like a workaround than a solution, and I’m not blaming them, that’s all they can do right now on mobile. Also, the fact that you have to find and set up individual rules one by one, like “leaving home” is also greatly limiting the possibilities of how app developers can make your phone a lot more useful. With the coming of wearables, this is gonna be even more relevant — they’re all about context-sensitivity, aren’t they?\nThese devices will be all about displaying the content you need, at the right time, by detecting where you are and what you’re up to.\nWithout an API like this, you’ll see only areally few apps that are actually useful.\nDo you have privacy concerns? Fair enough. I have privacy concerns. You need annoying popups to ask you whether you want to give this and that kind of access to the app. Which is fine. Or! We can have an AI that would predict which apps you want to give full access to. That would be awesome!\nI wrote this 6 months ago, and it does seem like this is getting fixed by a lot of companies. For example, Moves now has an API that does something similar. iOS8 clearly doesn\u0026rsquo;t do much about it, except on the fitness/health side. Sunrise, Gmail also started working on an API that would enable devs to build context-sensitive apps. It\u0026rsquo;s still not one brain that has all the information, but it\u0026rsquo;s getting easier to put together the pieces. Hurray!\n"});index.add({'id':13,'href':'/docs/archived-posts/2013-01-25-life-in-a-startup-incubator/','title':"2013 - Life in a startup incubator",'content':"Life in a startup incubator (I wish I had read this blogpost before I’ve got into one;)\nNow there are so many chances to travel, form a company and spend a 3-month period somewhere in the world - more than 300 tech-only startup incubators exist at the moment.\nWe ended up in Estonia and got a seed investment from GameFounders, Europe\u0026rsquo;s first gaming accelerator. First of all, it was an experience of a lifetime. Sort of like traveling to India for the first time. Not because Tallinn resembles Delhi or anything like that, but we all had to change our mindset, learn and adapt. We didn’t know what to expect at all. In early September, we were about to travel to a small country near Russia to participate in the first batch of a new seed incubator - without a contract that could have given us the least amount of security. We got the acceptance notice 9 days before setting off. I should have started my UX Design Masters in London in the middle of September.. The whole thing was a big mess!\nOne month later, we had two prototypes, an Estonian company, a seed investment, advice from 30+ mentors and a lot of opportunities. In one sentence: it was definitely worth it.\nBut, there were a lot of really unexpected realizations during the time I spent there and these were the most important ones:\n1. Seed incubators have only one goal business-wise: that you will get a second round investment as soon as possible. You\u0026rsquo;ll have one person organizing the fund-raising, pitching and networking almost full-time. This is a must, and you must plan accordingly. If only two of you are developing, designing and promoting the product, it will be really tough to get anything done during that 3 months period.\n2. You\u0026rsquo;re gonna burn the seed money in 3 months and after that you\u0026rsquo;ll have another 2-3 months to survive - because usually that\u0026rsquo;s how long it takes to finalize the second round. If you have a completed product and revenue by that time - you\u0026rsquo;re all set. If not, then you have something to figure out. But you love challenges, right?:)\n3. If you average out the advice you get from mentors, you\u0026rsquo;ll end up with the most generic product imaginable. There will be a point when you need to start ignoring them and ask why they want you to do - insert whatever advice you got from them -. They are mostly making assumptions based on their previous experience that has probably no use at all, as the market changed at least twice since they made their first success.\nAnd of course, no one knows how good luck helped them to succeed, there are too many variables. But, as the mentors you\u0026rsquo;ll meet are highly intelligent, they are the guys who really want to figure it all out. And that could easily result (unintentionally) in bad advice. Your job is to filter those and keep the rest.\n4. Going and staying lean is hard - and if you’re like most of us, it goes against your nature. \u0026ldquo;If you are not embarrassed by the first version of your product, you’ve launched too late.\u0026rdquo; Reid Hoffman\nBelieve me, the last thing you want is being embarrassed by \u0026ldquo;your baby\u0026rdquo; that you\u0026rsquo;ve spent all your time on for months. It requires constant, conscious effort and willpower, something like a diet, or quitting smoking.\nBut seriously, every minute your product stays in “stealth mode” is a minute wasted. Nothing works as you initially imagined, and the sooner you realize it, the better. We had to change the name of the application, the icon, the revenue model, and there will be a lot more to go. There’s a chance that the original concept will stay the same - although not much;).\n5. Planning for more than two weeks is sometimes necessary - but also, completely useless. So don\u0026rsquo;t put much effort in it. Before launching your product, financial forecasts look like this: You\u0026rsquo;re multiplying a random number (audience) with a random number (conversion rate) with a random number (the price you initially want to ask for). It means that you don’t have a faintest clue what the outcomes will be.\n6. The toughest decisions are the ones that don’t really matter. We spent days thinking and discussing “big” decisions we had to make - and at the end, we either had to choose a third option or the whole thing didn’t have any impact at all. You better set a time limit for each decision and if you can’t make up your mind within that limit, the pros and cons are probably so balanced out that you should just flip a coin. The biggest problem is that these “big decisions” don’t just waste time but consume a lot of energy, too.\n7. As a startup, you can move fast. You can change your entire business model in a really short period of time - and that\u0026rsquo;s something big organizations can\u0026rsquo;t do. This is you edge. Embracing uncertainty is something only startups can do. So, don’t be afraid. Anyway, the whole thing would be far less exciting without it. If you have an opportunity, seize it. Change whatever you need to change, don\u0026rsquo;t get attached to your plans, preconceptions or habits.\nSo we spent 3 months doing - most of the time - things we had not done before. And the beauty of it is that you can’t prepare for it in advance\u0026hellip; Problems come up, you have to learn how to solve them in a really short period of time and put your fresh knowledge into action like 5 minutes later. If you like these sort of things, you will be in the right place!\nYou should also read this thread on Quora, it’s funny as hell.\n"});index.add({'id':14,'href':'/docs/archived-posts/2014-01-01-designing-your-personal-identity/','title':"2014 - Designing your personal identity",'content':"Designing your personal identity So you are a graphic designer and you think you need a personal identity - not necessarily to show off your skills, but because you need to have one. And designing it can cause a lot of problems. I, myself can\u0026rsquo;t even count the hours I wasted on experimenting with my own personal identity - and still, it\u0026rsquo;s in \u0026ldquo;beta\u0026rdquo; at best.\nI mean, how can you have something as a graphic designer that both represents your skills, your mindset and your style when all of these variables are changing extremely fast? And I really do hope that none of them will eventually stop improving\u0026hellip;.\nBefore writing this post, I asked this question on Quora- I was really curious what experienced designers think on the topic, and I\u0026rsquo;ve got really cool answers that confirmed my superstition.\nThe conclusion is that I either need something that I can always fall back on, something that is so core that no new trend, Photoshop/Illustrator function or effect can override - or just eliminate the whole time-consuming and problem by having no personal identity. At least until somebody invents the automatically changing personal identity that needs no maintenance at all.I would definitely subscribe for a service like that.\n"});})();