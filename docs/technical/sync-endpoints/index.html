<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Sync APIs - git patch inspired non-blocking client-server communication pattern Three years ago, we were in a desperate need for a mental model: how to structure the highly asynchronous, non-blocking communication we have between our backend and mobile clients - where Read/Update are the only meaningful operations.
The solution we ended up with was something different than the currently popular CRUD / REST APIs (but closer to GraphQL’s) - and rather close to the concept of git’s patches / diffs."><meta property="og:title" content="Sync APIs - git patch inspired non-blocking client-server communication pattern"><meta property="og:description" content="Sync APIs - git patch inspired non-blocking client-server communication pattern Three years ago, we were in a desperate need for a mental model: how to structure the highly asynchronous, non-blocking communication we have between our backend and mobile clients - where Read/Update are the only meaningful operations.
The solution we ended up with was something different than the currently popular CRUD / REST APIs (but closer to GraphQL’s) - and rather close to the concept of git’s patches / diffs."><meta property="og:type" content="article"><meta property="og:url" content="https://itchingpixels.com/docs/technical/sync-endpoints/"><meta property="article:published_time" content="2020-04-04T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-08T20:52:29+02:00"><title>Sync APIs - git patch inspired non-blocking client-server communication pattern | Mark Aron Szulyovszky</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.63eb88daa545365405ecdbb21033286a325c60a36cfa6d22d21e7c3bc9286941.css integrity="sha256-Y+uI2qVFNlQF7NuyEDMoajJcYKNs+m0i0h58O8koaUE="><script defer src=/en.search.min.8aa936f253facaebe0ccdc7844e1e9d27e52a1b92a65db6aaf07206a95096fcd.js integrity="sha256-iqk28lP6yuvgzNx4ROHp0n5SobkqZdtqrwcgapUJb80="></script></head><body><input type=checkbox class=hidden id=menu-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>Mark Aron Szulyovszky</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/technical/ class=collapsed>Technical</a><ul><li><a href=/docs/technical/sync-endpoints/ class=active>Sync APIs - git patch inspired non-blocking client-server communication pattern</a></li></ul></li><li><a href=/docs/archived-posts/ class=collapsed>Archived posts</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Sync APIs - git patch inspired non-blocking client-server communication pattern</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div></header><article class=markdown><h1 id=sync-apis---git-patch-inspired-non-blocking-client-server-communication-pattern>Sync APIs - git patch inspired non-blocking client-server communication pattern</h1><p>Three years ago, we were in a desperate need for a mental model: how to structure the highly asynchronous, non-blocking communication we have between our backend and mobile clients - where Read/Update are the only meaningful operations.</p><p>The solution we ended up with was something different than the currently popular CRUD / REST APIs (but closer to GraphQL’s) - and rather close to the concept of git’s patches / diffs.</p><p>Linux kernel developers were sending patches to mailing lists, and releases were assembled by applying these patches. While this sounds like a horrendous model for release management today (I guess it works though!) - but as a mental model for reliably communicating changes, it may be a good alternative to the currently popular conventions in certain cases.</p><p>CRUD (the basis of REST apis) stands for Create Read Update Delete - which seemed a little bit of an overkill at that time for our use case:</p><ul><li>We had tons of small records, instead of a couple of big ones. Individual, non-batched updates wouldn’t have been efficient or easy to manage.</li><li>There was no need for “Delete”.</li><li>“Create” was really easy to couple with “Update”. So easy that differentiating between them would have only caused extra headaches.</li></ul><p>So, from CRUD, we needed “RU”.</p><p>But&mldr; the biggest problem wasn’t the unnecessary operations - but managing what happens when the user goes offline for a month, and then comes back online. Our worry was that, then the client could suddenly start sending out-of-date, cached requests to the backend.
The worst case would have been for us to lose that data, or the up-to-date properties being overwritten with previous ones.</p><h2 id=the-use-case-of-sync-apis>The use case of Sync APIs</h2><p>Two different communication patterns I see in contemporary software:</p><ul><li>software relying on frequent, blocking, real-time interaction (a social network, for example)</li><li>software relying on infrequent, non-blocking interaction with the server, which mostly stores data that the client needs to time-to-time (potentially, on different devices).
There are two different ways of how we could communicate change: in a batch (as a transaction) or individual changes, one-by-one.
(a presentation tool, a game, a brain training app or a mostly single-player experience)</li></ul><p>Example:
You have 3 post-its.</p><pre><code>interface PostIt {
    title: string
    status: “Available” | “Deleted”
    content: string
}
</code></pre><p>The actions you’ve done:</p><ol><li>You changed the 1st, named “birthdays” - PUT request to note/birthdays</li><li>Then, you deleted the 1st, named “birthdays” - DELETE request to note/birthdays</li><li>Then, you changed the 2nd, named “friends”. - PUT request to note/&lt;2nd name></li></ol><p>You could batch these, and only communicate the diff, if you added a property that would store the last action’s date/time.</p><pre><code>interface PostIt {
    title: string
    status: “Available” | “Deleted”
    content: string
    lastModified: number
}
</code></pre><p>A timestamp (lastModified) here would open up the possibility to compare and merge conflicting data effectively, by comparing what happened last.</p><pre><code>mergePostIts = (lhs, rhs): PostIt =&gt; 
</code></pre><p>Okay, right now it seems like we can only merge whole PostIts - as we only have one lastModified available. This means both status and content will be replaced with the value that was modified later. But… what if on one client, we changed the status, and on another, we changed the content? Well, you’d lose that information.
But there’s a way to prevent that from happening: have a timestamp on a property level, rather than on the larger context.</p><pre><code>Interface PostIt {
    status: {
        Value: “Available” | “Deleted”
        lastModified: number
    }
    content: {
        Value: “Available” | “Deleted”
        lastModified: number
    }
}
</code></pre><h2 id=advantages-of-sync-apis>Advantages of Sync APIs</h2><p>If you don’t need a separate “Create” operation, and your client-server communication can be made non-blocking for the user, the advantages of Sync APIs over CRUD/REST or GraphQL are:</p><ul><li>Offline support is easy. If the client can’t connect, it can still fall back to the local data it has. As every property has a timestamp, means it will be diffable on the backend later.</li><li>Business logic is concentrated on the backend.
The frontend blindly accepts (with some basic safety checks) what the backend returns.</li><li>Conflict resolution is easy (or, even free) if there are multiple clients editing the same data.</li><li>It’s easier to debug, as the business logic sits in the backend (the thing you’d debug)</li><li>You can reduce the number of requests</li></ul><p>We use Sync APIs at <a href=https://languagedrops.com>Drops</a>. Ours is probably the perfect usecase - we’re mobile (lots of offline usage), and there’s no real-time interaction, but it is possible that you play on multiple devices, and modify the same data.</p><p>Our frontend is written with React-native, and we’re using redux for state management. To make it easy to store lastModified timestamps, we wrote a higher level reducer that automatically adds a timestamp for each change (when it was initiated by the user).</p><h2 id=caveats-of-sync-apis>Caveats of Sync APIs</h2><ul><li><p>If a blocking “Create” operation is necessary (for example, because it’d generate a unique id), you can not use Sync APIs exclusively.</p></li><li><p>Have you noticed that git will create inconsistencies when you set your system’s time to arbitrary values? Probably not. But believe me, it does! Anyway, keeping the client’s clock “real” is a challenge. You may need to delay communication with the backend until you find that the time stamps are correct and are not in the future.</p></li><li><p>It may be useful to implement a mechanism on the backend side as well to filter out changes that happened “in the future”. Otherwise these users may not be able to override something they set while “in the future”.</p></li></ul></article><footer class=book-footer><div class="flex justify-between"><div><a class="flex align-center" href=https://github.com/itchingpixels/itchingpixels.github.io/commit/761c5eab17fd1f8e25f8b0f5dcc586c4c6852b13 title="Last modified by Mark Aron Szulyovszky | 2020 Apr 8" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>2020 Apr 8</span></a></div></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div></main></body></html>