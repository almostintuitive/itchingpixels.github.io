<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Big S(tate) notation This is an early and somewhat funny/incomprehendible post I wrote a long time ago about stateless / stateful components (not in a React, sense, but more in an OOP, object-sense).
There’s something that bothers me a little bit:
We have this useful thinking tool, Big 0 notation, to measure the computation complexity of an algorithm / function.
And it&rsquo;s great! We can anticipate the amount of time that a certain operation could take, and the necessary memory we need prepare for it, and it helps us architect our software, and forsee future problems without actually writing a line of code."><meta property="og:title" content="2016 - Big S(tate) notation"><meta property="og:description" content="Big S(tate) notation This is an early and somewhat funny/incomprehendible post I wrote a long time ago about stateless / stateful components (not in a React, sense, but more in an OOP, object-sense).
There’s something that bothers me a little bit:
We have this useful thinking tool, Big 0 notation, to measure the computation complexity of an algorithm / function.
And it&rsquo;s great! We can anticipate the amount of time that a certain operation could take, and the necessary memory we need prepare for it, and it helps us architect our software, and forsee future problems without actually writing a line of code."><meta property="og:type" content="article"><meta property="og:url" content="https://itchingpixels.com/docs/archived-posts/2016-01-09-big-s-notation/"><meta property="article:published_time" content="2016-01-09T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-04T15:01:40+02:00"><title>2016 - Big S(tate) notation | Mark Aron Szulyovszky</title><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.63eb88daa545365405ecdbb21033286a325c60a36cfa6d22d21e7c3bc9286941.css integrity="sha256-Y+uI2qVFNlQF7NuyEDMoajJcYKNs+m0i0h58O8koaUE="><script defer src=/en.search.min.b0eb1373e5c8274961b22c9e01d1888b96c96166301e743425200bffa7c9b31e.js integrity="sha256-sOsTc+XIJ0lhsiyeAdGIi5bJYWYwHnQ0JSAL/6fJsx4="></script></head><body><input type=checkbox class=hidden id=menu-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>Mark Aron Szulyovszky</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/technical/ class=collapsed>Technical</a></li><li><a href=/docs/quantitative-finance/ class=collapsed>Quantitative Finance</a></li><li><a href=/docs/archived-posts/ class=collapsed>Archived posts</a><ul><li><a href=/docs/archived-posts/2016-01-30-functional-reactive-intuition-swift/>2016 - Functional Reactive Intuition - Swift edition</a></li><li><a href=/docs/archived-posts/2016-01-09-big-s-notation/ class=active>2016 - Big S(tate) notation</a></li><li><a href=/docs/archived-posts/2016-01-08-making-mistakes/>2016 - Making mistakes</a></li><li><a href=/docs/archived-posts/2015-08-09-post-text-messaging/>2015 - Post-text messaging?</a></li><li><a href=/docs/archived-posts/2014-09-07-anatomy-of-a-touch-interaction-swipe-to-peep/>2014 - Anatomy of a touch interaction: Swipe-to-peep</a></li><li><a href=/docs/archived-posts/2014-03-24-todays-mobile-context-insensitivity/>2014 - Today’s mobile context-insensitivity</a></li><li><a href=/docs/archived-posts/2013-01-25-life-in-a-startup-incubator/>2013 - Life in a startup incubator</a></li><li><a href=/docs/archived-posts/2014-01-01-designing-your-personal-identity/>2014 - Designing your personal identity</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>2016 - Big S(tate) notation</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div></header><article class=markdown><h1 id=big-state-notation>Big S(tate) notation</h1><p><em>This is an early and somewhat funny/incomprehendible post I wrote a long time ago about stateless / stateful components (not in a React, sense, but more in an OOP, object-sense).</em></p><p>There’s something that bothers me a little bit:</p><p>We have this useful thinking tool, <a href=https://en.wikipedia.org/wiki/Big_O_notation>Big 0 notation</a>, to measure the computation complexity of an algorithm / function.</p><p>And it&rsquo;s great! We can anticipate the amount of time that a certain operation could take, and the necessary memory we need prepare for it, and it helps us architect our software, and forsee future problems without actually writing a line of code.</p><p>But, do we have a good thinking tool for the <strong>understanding (human) complexity of a component</strong>?</p><p>I’ll struggle a little bit here, since I don’t have a clear definition of “understanding complexity”.</p><p>Maybe it’s easier to just describe what a simple component is in my mind:</p><ul><li>has very little or no state</li><li>mutates its state very rarely (or never)</li><li>it’s easy to reproduce a situation where the component is in a certain kind of state.</li></ul><p>I’d consider a string conversion component very simple, since all its functions will be pure: they’ll get an input string and they’ll produce an output string.</p><p>In contrast, a complex component:</p><ul><li>has lots of states</li><li>mutates its state very frequently</li><li>it’s hard to reproduce a situation where the component is in a certain kind of state.</li></ul><p>I’d consider a database component to be very complex, since none of its public functions will be pure: it’ll have to insert, modify and delete records, write them to the disk, cache them, etc.</p><p>It could be very useful to have a thinking tool for this kind of complexity: let’s call it the <strong>big S(tate) notation</strong>.</p><p>But… could for example, a linter or a complier classify a component as “complex” or “simple”?
Would it be possible to find that out, just by parsing the code and identifying some keywords?</p><p>There are two ideas to play with:</p><p><em>How many variables are defined in global scope of the component (aka. properties)?</em>
This will give you a good indication of how many different state it can have.</p><p><em>What’s the ratio of pure vs. impure functions (methods) the component has?</em></p><hr><p>Sorry if I jumped too far too quickly - let’s define what pure and impure functions are. This is not something I made up, promise. They even have <a href=https://en.wikipedia.org/wiki/Pure_function>wikipedia articles</a>!</p><p>Let’s say:
A <strong>pure function</strong> is where you don’t modify or read anything outside of the scope of the function. You get the parameters, you transform them, and you return a value. It’s completely predictable - call it twice with the same input, and it’s guaranteed that it’ll produce the same result.</p><p>An <strong>impure function</strong> is where you take some parameters, but you also access some other properties of the component, change them, and then you return a value. It can be unpredictable - call it twice with the same input, and you can be never sure if you get the same result - since it’s using (and possibly) modifying state, outside of its parameters.</p><p>A pure function is like asking your computer to turn down the music it’s playing. It’ll do it as soon as you press the button.</p><p>An impure function is like asking a neighbour to turn down the music while it’s having a house party. He/she may say “go to hell” and turn up the volume in response, depending on how drunk he/she is, and various other factors.</p><hr><p>The million dollar question is:</p><p><strong>How can you reduce the understanding complexity of a component that’s main function is to mutate its state?</strong></p><p>So that you can’t remove any of its defined variables.</p><p>Is that possible?
Now, if we have a look at the Big S(tate) notation definition above, we can slightly rephrase this question to:</p><p><em>Can you increase the ratio of pure vs. impure functions in your component?</em></p><p>What do you think? Does this make sense?</p><p>I’ll continue later, but if you’re curious, have a look at <strong><a href=https://github.com/rackt/redux>redux</a></strong> and the <strong><a href=https://egghead.io/series/getting-started-with-redux>explanation of how it works by its author</a></strong>.</p><p>Shout on <a href=https://twitter.com/itchingpixels>twitter</a> if you find this horrendous / incorrenct or something you can relate to, I&rsquo;d love to hear about it.</p></article><footer class=book-footer><div class="flex justify-between"><div><a class="flex align-center" href=https://github.com/itchingpixels/itchingpixels.github.io/commit/b367a8fab2680f11686519bc3d5addebaed397fa title="Last modified by Mark Aron Szulyovszky | 2020 Apr 4" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>2020 Apr 4</span></a></div></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div></main></body></html>